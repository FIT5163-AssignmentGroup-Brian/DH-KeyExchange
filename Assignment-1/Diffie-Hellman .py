import random
from hashlib import sha256

# Author: Ziyuan Wang

# Global prime number p and generator g for Diffie-Hellman
# In practice, p should be a large prime number, and g should be a generator of the multiplicative group modulo p
p = 23  # Example small prime (use a large prime in real applications)
g = 5   # Example generator (use a suitable generator for the chosen prime)

# Function to generate a private key
def generate_private_key(p):
    """
    Generates a random private key within the range [1, p-2].
    :param p: Prime number used as modulus in Diffie-Hellman.
    :return: A random private key.
    """
    return random.randint(1, p - 2)

# Function to generate a public key
def generate_public_key(private_key, g, p):
    """
    Generates the public key using the private key, generator g, and prime p.
    Public key = g^private_key mod p
    :param private_key: The private key generated by the user.
    :param g: The generator for Diffie-Hellman.
    :param p: Prime number used as modulus in Diffie-Hellman.
    :return: The public key.
    """
    return pow(g, private_key, p)

# Function to compute the shared secret key
def compute_shared_secret(their_public_key, your_private_key, p):
    """
    Computes the shared secret using the other party's public key and your private key.
    Shared Secret = (their_public_key)^your_private_key mod p
    :param their_public_key: The public key received from the other party.
    :param your_private_key: The private key generated by the user.
    :param p: Prime number used as modulus in Diffie-Hellman.
    :return: The shared secret.
    """
    return pow(their_public_key, your_private_key, p)

# Function to generate a MAC for a given message
def generate_mac(message, key):
    """
    Generates a MAC for a given message using a shared key.
    :param message: The message to be authenticated.
    :param key: The shared key used to generate the MAC.
    :return: The generated MAC.
    """
    return sha256((message + key).encode()).hexdigest()

# Function to verify the MAC of a received message
def verify_mac(received_message, received_mac, key):
    """
    Verifies the MAC of a received message.
    :param received_message: The received message.
    :param received_mac: The received MAC.
    :param key: The shared key used to verify the MAC.
    :return: True if MAC is valid, False otherwise.
    """
    generated_mac = generate_mac(received_message, key)
    return generated_mac == received_mac

# Example: Theo and Knew establish a shared secret using Diffie-Hellman

# Step 1: Theo and Knew generate their private keys
theo_private_key = generate_private_key(p)
knew_private_key = generate_private_key(p)

# Step 2: Theo and Knew generate their public keys
theo_public_key = generate_public_key(theo_private_key, g, p)
knew_public_key = generate_public_key(knew_private_key, g, p)

# Step 3: Theo and Knew exchange their public keys and compute the shared secret
theo_shared_secret = compute_shared_secret(knew_public_key, theo_private_key, p)
knew_shared_secret = compute_shared_secret(theo_public_key, knew_private_key, p)

# Step 4: Verify that both shared secrets are identical
assert theo_shared_secret == knew_shared_secret, "Shared secrets do not match!"
print("Shared secret successfully established.")
print(f"Theo's shared secret: {theo_shared_secret}")
print(f"Knew's shared secret: {knew_shared_secret}")

# Extend to Password Authenticated Key Exchange (PAKE) using a shared password

# Assume Theo and Knew have a pre-shared password
shared_password = "securepassword123"

# Function to generate a hash of the password combined with a salt
def generate_password_hash(password, salt):
    """
    Generates a hash of the password combined with a salt using SHA-256.
    :param password: The shared password between Theo and Knew.
    :param salt: A salt value to add randomness to the password hash.
    :return: A hashed value derived from the password and salt.
    """
    return int(sha256((password + salt).encode()).hexdigest(), 16)

# Simple salt value for demonstration purposes (in practice, use a randomly generated salt)
salt = "random_salt"

# Generate a hash of the shared password with the salt
password_hash = generate_password_hash(shared_password, salt)

# Function to combine the shared secret with the password hash
def combine_with_password(shared_secret, password_hash):
    """
    Combines the shared secret with the password hash to generate a final authenticated key.
    The combination is done using modular addition followed by hashing.
    :param shared_secret: The shared secret established through Diffie-Hellman.
    :param password_hash: The hash of the shared password.
    :return: The final combined key as a SHA-256 hash.
    """
    combined = (shared_secret + password_hash) % p
    return sha256(str(combined).encode()).hexdigest()

# Step 5: Theo and Knew compute their final authenticated key using the password
theo_final_secret = combine_with_password(theo_shared_secret, password_hash)
knew_final_secret = combine_with_password(knew_shared_secret, password_hash)

# Step 6: Verify that both final secrets are identical
assert theo_final_secret == knew_final_secret, "Final shared secrets do not match!"
print("Password-authenticated shared secret successfully established.")
print(f"Theo's final secret: {theo_final_secret}")
print(f"Knew's final secret: {knew_final_secret}")

# Step 7: Use the final authenticated key to generate and verify a MAC for a message
# Example message
message = "This is a secure message."

# Generate a MAC for the message
mac = generate_mac(message, theo_final_secret)
print(f"Generated MAC: {mac}")

# Simulate sending the message and MAC to Knew
received_message = message  # Assume the message is received correctly
received_mac = mac  # Assume the MAC is received correctly

# Knew verifies the MAC
if verify_mac(received_message, received_mac, knew_final_secret):
    print("Message is verified and intact.")
else:
    print("Message verification failed! Possible modification detected.")
